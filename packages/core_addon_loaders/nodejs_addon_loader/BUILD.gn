#
# Copyright Â© 2025 Agora
# This file is part of TEN Framework, an open source project.
# Licensed under the Apache License, Version 2.0, with certain conditions.
# Refer to the "LICENSE" file in the root directory for more information.
#
import("//build/feature/ten_package.gni")
import("//build/ten_runtime/feature/publish.gni")
import("//build/ten_runtime/glob.gni")
import("//build/ten_runtime/options.gni")

# Copy node shared library to addon_loader package
# Platform-specific handling:
# - Linux: libnode.so.127 + symlink libnode.so
# - Mac:   libnode.127.dylib + symlink libnode.dylib
# - Win:   libnode.dll (no symlink needed)

if (is_win) {
  action("copy_node_shared_lib") {
    script = "//.gnfiles/build/scripts/copy_fs_entry.py"

    _source_lib = "${root_out_dir}/prebuilt/node_shared/lib/libnode.dll"
    _dest_lib = "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader/lib/libnode.dll"

    args = [
      "--source",
      rebase_path(_source_lib),
      "--destination",
      rebase_path(_dest_lib),
    ]

    sources = [ _source_lib ]
    outputs = [ _dest_lib ]

    deps = [ "//third_party/node" ]
  }

  # Windows doesn't need symlinks, create a no-op group
  group("create_symlink") {
    deps = [ ":copy_node_shared_lib" ]
  }
} else {
  action("copy_node_shared_lib") {
    script = "//.gnfiles/build/scripts/copy_fs_entry.py"

    # Determine shared library naming based on platform
    # Linux: libnode.so.127
    # Mac:   libnode.127.dylib
    if (is_mac) {
      _source_lib = "${root_out_dir}/prebuilt/node_shared/lib/libnode.127.dylib"
      _dest_lib = "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader/lib/libnode.127.dylib"
    } else {
      _source_lib = "${root_out_dir}/prebuilt/node_shared/lib/libnode.so.127"
      _dest_lib = "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader/lib/libnode.so.127"
    }

    args = [
      "--source",
      rebase_path(_source_lib),
      "--destination",
      rebase_path(_dest_lib),
    ]

    sources = [ _source_lib ]
    outputs = [ _dest_lib ]

    deps = [ "//third_party/node" ]
  }

  action("create_symlink") {
    script = "//build/ten_common/scripts/create_symlink.py"

    # Determine shared library naming based on platform
    # Linux: libnode.so -> libnode.so.127
    # Mac:   libnode.dylib -> libnode.127.dylib
    if (is_mac) {
      _versioned_lib = "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader/lib/libnode.127.dylib"
      _symlink_lib = "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader/lib/libnode.dylib"
    } else {
      _versioned_lib = "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader/lib/libnode.so.127"
      _symlink_lib = "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader/lib/libnode.so"
    }

    args = [
      rebase_path(_versioned_lib),
      rebase_path(_symlink_lib),
    ]

    sources = [ _versioned_lib ]
    outputs = [ _symlink_lib ]

    deps = [ ":copy_node_shared_lib" ]
  }
}

config("nodejs_addon_loader_config") {
  # Prevent Windows SDK min/max macros from conflicting with std::min/max
  if (is_win) {
    defines = [ "NOMINMAX" ]
  }

  if (is_win && !is_mingw) {
    # MSVC or clang-cl on Windows uses /std:c++17
    cflags_cc = [ "/std:c++17" ]

    # Use dynamic RELEASE CRT (/MD) to match the prebuilt libnode.dll.
    # libnode.dll imports VCRUNTIME140.dll / MSVCP140.dll (release, no "D"),
    # so we must use /MD even in debug builds. Using /MDd would link against
    # VCRUNTIME140D.dll (debug), causing STL layout mismatches when passing
    # std::vector<std::string> across the DLL boundary to
    # node::InitializeOncePerProcess().
    #
    # This overrides the global /MTd set by common_cflags and msvc:debug
    # configs. When both /MT and /MD appear, clang-cl uses the last one.
    cflags = [ "/MD" ]

    # Disable MSVC debug iterator checks to match libnode.dll's release STL
    # layout. Without this, _DEBUG causes std::vector/std::string to have
    # extra debug fields that don't exist in the release-built libnode.dll.
    defines += [
      "_ITERATOR_DEBUG_LEVEL=0",
      "_HAS_ITERATOR_DEBUGGING=0",
    ]
  } else {
    # GCC, Clang, MinGW use -std=c++17
    cflags_cc = [ "-std=c++17" ]

    if (is_clang && !is_mac && !is_win) {
      cflags_cc += [ "-stdlib=libstdc++" ]
      libs = [ "stdc++" ]
    }
  }
}

ten_package("nodejs_addon_loader") {
  package_kind = "addon_loader"
  enable_build = true

  resources = [
    "LICENSE",
    "manifest.json",
    "property.json",
  ]

  # On Windows (non-MinGW), force linking against the RELEASE dynamic CRT
  # to match the prebuilt libnode.dll (which uses VCRUNTIME140.dll, not
  # VCRUNTIME140D.dll). The msvc:debug config adds debug CRT import libs
  # (msvcrtd.lib, ucrtd.lib, vcruntimed.lib), so we must exclude them
  # and substitute the release versions.
  if (is_win && !is_mingw && is_debug) {
    ldflags = [
      "/NODEFAULTLIB:msvcrtd.lib",
      "/NODEFAULTLIB:ucrtd.lib",
      "/NODEFAULTLIB:vcruntimed.lib",
      "/NODEFAULTLIB:libcmtd.lib",
      "/NODEFAULTLIB:libucrtd.lib",
      "/NODEFAULTLIB:libvcruntimed.lib",
    ]
    libs = [
      "msvcrt.lib",
      "ucrt.lib",
      "vcruntime.lib",
    ]
  }

  docs_files = exec_script("//.gnfiles/build/scripts/glob_file.py",
                           [
                             "--dir",
                             rebase_path("docs/**/*"),
                             "--dir-base",
                             rebase_path("docs"),
                             "--recursive",
                             "--only-output-file",
                           ],
                           "json")

  foreach(docs_file, docs_files) {
    docs_file_rel_path = docs_file.relative_path
    resources += [ "docs/${docs_file_rel_path}=>docs/${docs_file_rel_path}" ]
  }

  configs = [ ":nodejs_addon_loader_config" ]

  sources = [ "src/main.cc" ]
  include_dirs = [ "//core" ]

  deps = [
    ":create_symlink",
    "//core/src/ten_runtime",
    "//third_party/node",
  ]

  lib_dirs =
      [ "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader/lib" ]
}

if (ten_enable_ten_manager) {
  ten_package_publish("upload_nodejs_addon_loader_to_server") {
    base_dir = rebase_path(
            "${root_out_dir}/ten_packages/addon_loader/nodejs_addon_loader")
    deps = [ ":nodejs_addon_loader" ]
  }
}
